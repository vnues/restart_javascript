
迭代：迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的`初始值`。


模式：模式即是一种思想

<!-- 当我们去访问一个数组一个对象的属性时候往往第一反应就是用for循环（for循环实际就是第一个迭代的过程，`但记住不是迭代模式`，模式指的是一种思想）然后在循环里面做业务逻辑   这是开发中不优雅的写法 ，`我们希望我们的迭代过程和业务逻辑分离出来，`所以我们才会想到用迭代模式解决这种问题，而不是每次去访问一个聚合对象就写一次`(for循环重复性代码)`,所以开发中你不要去写for循环去访问，要么就用迭代模式去设计一个`迭代器`，我们Js就有内置的迭代器 forEach,map,for..in..,想想这也是我们之前嫌弃for循环麻烦，而写forEach,map,for..in..等但要更加清楚自己为什么这么用orEach,map,for..in.. -->   错误的想法

迭代器是什么？迭代器模式是什么？


❗️❗️❗️更加清楚自己为什么使用forEach等内置迭代器了，而不是用for循环


迭代器模式：
把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构。


for循环是迭代器吗  理解迭代的意思



其实可以这样写
```js
 for(let i=0;i<a.length;i++){
    // 业务代码
 }
```


迭代器模式是指提供一种方法顺序访问一个聚合对象的各个元素


就是我们的作用对象就是聚合对象  然后我们想要去访问各个对象  <-----这就是迭代器模式

不管内部怎么去实现它    ----->

> 遍历一个聚合对象，这是迭代器模式的作用。



我们如何遍历数组中的元素？20 年前 JavaScript 刚萌生时，你可能这样实现数组遍历：

复制代码


for (var index = 0; index < myArray.length; index++) {
  console.log(myArray[index]);
}




自 ES5 正式发布后，你可以使用内建的forEach方法来遍历数组：

复制代码

 
myArray.forEach(function (value) {
console.log(value);
});

这段代码看起来更加简洁，但这种方法也有一个小缺陷：你不能使用break语句中断循环，也不能使用return语句返回到外层函数。


迭代器是一种模式，它可以使得对于序列类型的数据结构的遍历行为与被遍历的对象分离，即我们无需关心该序列的底层结构是什么样子的。只要拿到这个对象,使用迭代器就可以遍历这个对象的内部.



（1）内部迭代器：已经定义好了迭代规则，它完全接手整个迭代过程，外部只需一次初始调用。上述自定义each即为内部迭代器！ 
（2）外部迭代器：必须显示地请求迭代下一个元素。 


### 首先来理解迭代的概念

[1,2,3,4] 要经过四次迭代   for循环就是一个内部迭代器  它定义好了规则 比如怎么去执行下一次迭代


开头是错误的想法


一个问题 for循环是怎么实现的？  for循环本身就是个迭代器  它已经帮我们实现好了迭代规则   

迭代：迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的`初始值`。

> MDN:处理集合中的每个项是很常见的操作。JavaScript 提供了许多迭代集合的方法，从简单的 for 循环到 map() 和 filter()。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for...of 循环的行为


❗️❗️❗️for循环内置了是简单的内部迭代器  我们可以包装成高级点的forEach 迭代器


迭代器：在 JavaScript 中一个 iterator 就是一个对象可以定义一个序列以及在终止时返回的值

迭代是遍历的一种形式。

遍历，其实就是访问数据结构的所有元素，形式多样，比如前递归、尾递归之类。

for循环的工作原理
```javascript
#for循环的工作原理
#1：执行in后对象的dic.__iter__()方法，得到一个迭代器对象iter_dic
#2: 执行next(iter_dic),将得到的值赋值给k,然后执行循环体代码
#3: 重复过程2，直到捕捉到异常StopIteration,结束循环
```
https://www.cnblogs.com/lt123456/p/9859138.html

for循环，我们最熟悉也是最常用的循环迭代方式，后来的许多迭代方法都是基于for循环封装的。


❗️❗️❗️所以for循环表达式其实就是内置了内部迭代器


迭代器是一个对象，用于将容器对象作为列表遍历。在 JavaScript 中，迭代器对象不是一个独立的内置对象，而是一个实现 next 方法以访问容器对象中的下一项的对象。
JavaScript 迭代器的实现涉及符合特定接口的两个或三个对象：

Iterable 接口
可迭代对象必须提供 Symbol.iterator 方法，该方法会返回一个迭代器。


ES6中的集合对象，数组、Set集合和Map集合，都内建了三种迭代器：

entries() 返回一个迭代器，其值为多个键值对。
如果是数组，第一个元素是索引位置；如果是Set集合，第一个元素与第二个元素一样，都是值。

values() 返回一个迭代器，其值为集合的值。

keys() 返回一个迭代器，其值为集合中的所有键名。
如果是数组，返回的是索引；如果是Set集合，返回的是值（Set的值被同时用作键和值）。




### 搞清楚什么是迭代器和迭代器模式

数组有内建迭代器 

迭代器是一种对象  迭代器模式是一种方法（不一定是函数）：`迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素`，而又不需要暴露该对象
的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即
使不关心对象的内部构造也可以按顺序访问其中的每个
像for循环就是一种方法去法顺序访问一个聚合对象中的各个元素   -----> for循环的实现原理

```javascript
// for(let i=0;i<4;i++){
  console(i)
}
var Iterator = function( obj ){ 
 var current = 0; 
 
 var next = function(){ 
 current += 1; 
 }; 
 var isDone = function(){ 
 return current >= obj.length; 
 }; 
 var getCurrItem = function(){ 
 return obj[ current ]; 
 }; 
 // 存在引用函数内部的方法  --->方法内使用函数的变量  闭包
 return { 
 next: next, 
 isDone: isDone, 
 getCurrItem: getCurrItem 
 } 
}; 


```

for循环的实现原理？



### 内部迭代器模式

### 外部迭代器模式



### 为什么死抓原生？--->死抓原生是为了理解函数式编程 面向对象编程 设计模式

❗️我觉得正在往着正确的道路成长  还是一句话 不看重框架 不认为会框架很厉害 深挖底层❗️❗️❗️包括这一年或者两年都是❗️❗️❗️不追求快❗️❗️❗️只追求底子打好❗️❗️ 然后看框架 库源码 去分析 ❗️❗️❗️这是一种学习方式  
❗️❗️❗️这个周期是under周期源码的分析  不要快 慢些也无所谓❗️❗️❗️

#### 为什么死抓数据结构和算法  ----->学哪一门语言都离不开它们  
❗️死抓数据结构和算法  这是第二年考虑的事情  现在也要定方向

以上两个都是桥梁




为什么使用迭代器模式？

访问聚合对象的元素   for循环就是迭代器模式的使用不不不       for循环里面是内置了迭代器？？？ 也是种错误的认知?  迭代器是种对象

迭代器模式的使用场景是：对于集合内部结果常常变化各异，我们不想暴露其内部结构的话，但又想让用户代码透明底访问其中的元素，这种情况下我们可以使用迭代器模式。




for循环里面内置了迭代器 但是 不是迭代器模式


想想我们如何有`顺序`的去访问一个聚合对象的元素




解释不通  再想想



迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象
的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即
使不关心对象的内部构造，也可以按顺序访问其中的每个元素

理解好这句话:比如一个数组let a=[1,12,3] 开发者并不想想用a[index]这种方式去拿到聚合对象的元素 我们这种写法得去了解它的内部构造  然后各种按照不同的方式去处理，显然不想看到的 出现个对象let obj={name:"vnues"} 我们还得这样去表示obj.a

想想你用一种方法 聚合对象经过这个方法  直接返回这个值就行  聚合对象元素的表示方法我们并不关心  是这理解的 对吧

在使用迭代器模式之后，即
使不关心对象的内部构造，也可以按顺序访问其中的每个元素


像forEach

```javascript
// const obj={
//    name:"vnues",
//    age:12,
//    height:170
// }
[1,2,3].forEach((item)=>{
   console.log(item)
})
```
顺序去访问一个聚合对象需要迭代器才能访问   而for循环已经是帮我们操作了迭代器   所以说for循环内置迭代器的说法是错误的   迭代器是种对象 我们通过操作这个对象去迭代

```javascript
var Iterator = function( obj ){ 
  var current = 0; 
  var next = function(){ 
  current += 1; 
  }; 
  var isDone = function(){ 
  return current >= obj.length; 
  }; 
  var getCurrItem = function(){ 
  return obj[ current ]; 
  }; 
  return { 
  next: next, 
  isDone: isDone, 
  getCurrItem: getCurrItem 
  } 
}; 
```
迭代器模式
迭代器模式无非就是循环访问聚合对象中的各个元素

迭代器模式是指提供一种方法`顺序`访问一个聚合对象中的各个元素，而又不需要暴露该对象
的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即
使`不关心对象的内部构造`也可以按顺序访问其中的每个


迭代器模式是指提供一种方法-->函数   for循环是有去操作了迭代器我估计的   总之for循环          很奇怪 我们可以抛弃它

我们所说的迭代器模式可以这样认为：一是方法能够顺序访问一个聚合对象中的各个元素（这需要去操作迭代器跟for循环一样 for循环也是操作迭代器） 即使`不关心对象的内部构造`也可以按顺序访问其中的每个   首先明白访问这个聚合对象的元素  实际就是为了拿到对象元素的value 这是我们开发中关心的 但如果用for循环我们还得去表示它  难受  采用迭代器模式去解决这种问题❗️❗️❗️

对比就来  使用for循环我们需要去关心聚合对象的表示

```javascript
const arr =[1,2,3]
for(var i=0;i<arr.length;i++){
 //  即使`不关心对象的内部构造`也可以按顺序访问其中的每个
  // 我们需要关心到这种写法  而且我们是通过下标去访问对象元素 
   arr[i]
}
```

- for循环不是迭代器模式
- 迭代器模式需要去操作迭代器（对象）跟for循环操作迭代器一样的
- 之所以使用迭代器模式而不用for循环  意思就是for循环实际是有限制 通常用于数组   它们都是通过操作迭代器顺序访问对象
但是关心对象的内部构造   --- 所以内部迭代器可以借用for循环操作迭代器已经完成的一点进行再次封装就行


也就是再总结下：满足迭代器模式两点  需要操作迭代器：一是方法能够顺序访问一个聚合对象中的各个元素 二是：即使`不关心对象的内部构造`也可以按顺序访问其中的每个

满足这两点   终于说通了   


想想我们如果不依赖for循环自己怎么访问一个聚合对象  （不要想到访问聚合对象,就for循环遍历 ） 得清楚本质  for循环也是去操作迭代器的   forEach内部迭代器模式 是对for循环的再次封装    但是不依靠for循环我们访问聚合对象  就得依靠操作迭代器了  也就是自己去操作第一步了  这也就是外部迭代器的由来  ---终于搞清楚了❗️❗️❗️

看看下面的例子  也是有点东西的


```javascript
const obj={
   name:"vnues",
   age:12,
   height:170
}

const arr=['name','age','height']

for(let i=0;i<arr.length;i++){
   obj[arr[i]]
}


```

迭代：迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的`初始值`。

看迭代的定义就知道为什么可以顺序遍历数组

模式就是增加了一个思想 即使`不关心对象的内部构造`也可以按顺序访问其中的每个