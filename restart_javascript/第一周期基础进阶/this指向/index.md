❗️❗️❗️当前函数的 this 是在 数被调用执行的时候才确定
正是由于这个原因，才导致一个函数内部的 hi 到底指向谁是非常灵活且不确定的



### 全局this


### 函数this

❗️❗️❗️

在一个函数的执行上下文中， this 由该函数的调用者提供，由调用函数的方式来决定其指向

```javascript
  
   function fn() { 
   console.log(this); 
   } 
   fn(); // 11 fn 为调用者

```
如果调用者被某一个对象所拥有，那么在调用该函数 this 指向该`对象` 如果调用
者函数独立调用，那么该函数内部的 this 则指向 undefined(你可以把这句话理解为规则 不然以为打印出的this是fn) 但是在非严格模式中， this 指向
undefined 时，它会自动指向全局对象

```javascript
// 为了能够准确判断，我们在函数 部使 严格模式
// 因为非严格模式会 动指向全局
function fn() { 
’ use strict ’; 
console.log(this) ; 
} 
fnO ; // 11 fn是调用者 独立调用 this undefined
window. fn () ;// 但是调用者，被window 所拥 有， this window 对象
```

### 执行上下文



## 前提

很多种情况我们使用this 想要知道this的指向需要判断下应用场景 是全局的this场景（比如你在全局是这样使用的this.a 那么这就是this应用全局场景）
也可能是函数的this场景（最常见  所以this很灵活）

以前说过 this的所处环境（执行上下文是谁）就指向谁  这说法显然是不正确的

我们现在做的区别是看场景来应用this 来确定this执行  这和执行上下文息息相关❗️❗️❗️

### 为啥和执行上下文息息相关❗️❗️❗️
JavaScript 代码在执行时，会进入一个执行上下文 假如我运行this.a（不在函数体里）（想想你的代码段要么就是在全局运行要么就是函数运行对吧）这段代码的执行上下文就是全局环境了 所以属于全局this场景

### 执行上下文是什么

执行上下文可以理解为当前代码的运行环境
全局环境：代码运行起来后会首先进入全局环境
函数环境 当函数被调用执行时，会进入当前函数中执行代码
eval 环境：不建议使用，这里不做介绍

因此可以预见的是，在 JavaScript 程序中，必定会出现多个执行上下文



总结最后一句话  this的指向判断由场景判断再确定指向

网上最多的一句话 谁最终调用 this就指向谁  <----- 这句话实际应该归于函数this场景
❗️❗️❗️

❗️❗️❗️ 清楚明白啊


还有注意的一点

全局对象中  this.a <======>var a=...